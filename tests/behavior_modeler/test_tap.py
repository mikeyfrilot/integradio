"""
Tests for BehaviorTap - Event capture and session management.

Generated by Dev Brain to achieve 100% coverage of tap.py.
"""

import asyncio
import pytest
from datetime import datetime, timezone, timedelta
from unittest.mock import MagicMock, AsyncMock, patch

from behavior_modeler.tap import BehaviorTap, run_tap_standalone
from behavior_modeler.config import BehaviorModelerConfig
from behavior_modeler.models import Session, FlowEvent
from behavior_modeler.store import FlowStore


# =============================================================================
# Fixtures
# =============================================================================

@pytest.fixture
def mock_store():
    """Create a mock FlowStore."""
    store = MagicMock(spec=FlowStore)
    store.save_session = MagicMock(return_value=True)
    return store


@pytest.fixture
def config():
    """Create test configuration."""
    return BehaviorModelerConfig(
        max_events_per_session=100,
        session_timeout_seconds=300,
    )


@pytest.fixture
def tap(mock_store, config):
    """Create a BehaviorTap instance."""
    return BehaviorTap(store=mock_store, config=config)


@pytest.fixture
def mock_mesh():
    """Create a mock EventMesh."""
    mesh = MagicMock()
    mesh.subscribe = MagicMock(return_value="sub_123")
    mesh.unsubscribe = MagicMock()
    return mesh


@pytest.fixture
def mock_event():
    """Create a mock SemanticEvent."""
    event = MagicMock()
    event.type = "ui.button.click"
    event.correlation_id = "session_abc123"
    event.source = "client_1"
    event.data = {"component_id": 42, "value": "clicked"}
    event.time = datetime.now(timezone.utc).isoformat()  # SemanticEvent uses 'time' as string
    return event


@pytest.fixture
def mock_registry():
    """Create a mock ComponentRegistry."""
    registry = MagicMock()
    registry.get = MagicMock(return_value={"name": "TestComponent", "type": "button"})
    return registry


# =============================================================================
# Initialization Tests
# =============================================================================

class TestBehaviorTapInit:
    """Tests for BehaviorTap initialization."""

    def test_init_with_defaults(self, mock_store):
        """Test initialization with default config."""
        tap = BehaviorTap(store=mock_store)

        assert tap.store == mock_store
        assert tap.config is not None
        assert tap.registry is None
        assert tap._sessions == {}
        assert tap._running is False
        assert tap._events_captured == 0
        assert tap._sessions_completed == 0

    def test_init_with_config(self, mock_store, config):
        """Test initialization with custom config."""
        tap = BehaviorTap(store=mock_store, config=config)

        assert tap.config == config

    def test_init_with_registry(self, mock_store, mock_registry):
        """Test initialization with ComponentRegistry."""
        tap = BehaviorTap(store=mock_store, registry=mock_registry)

        assert tap.registry == mock_registry

    def test_terminal_events_defined(self, tap):
        """Test that terminal events are defined."""
        assert "submit" in tap.TERMINAL_EVENTS
        assert "logout" in tap.TERMINAL_EVENTS
        assert "close" in tap.TERMINAL_EVENTS

    def test_subscribe_patterns_defined(self, tap):
        """Test that subscription patterns are defined."""
        assert "ui.**" in tap.SUBSCRIBE_PATTERNS
        assert "data.**" in tap.SUBSCRIBE_PATTERNS


# =============================================================================
# Start/Stop Tests
# =============================================================================

class TestBehaviorTapStartStop:
    """Tests for start and stop functionality."""

    @pytest.mark.asyncio
    async def test_start_subscribes_to_mesh(self, tap, mock_mesh):
        """Test that start() subscribes to the mesh."""
        await tap.start(mock_mesh)

        mock_mesh.subscribe.assert_called_once()
        call_kwargs = mock_mesh.subscribe.call_args
        assert call_kwargs[1]["patterns"] == tap.SUBSCRIBE_PATTERNS
        assert call_kwargs[1]["client_id"] == "behavior_modeler"
        assert tap._running is True
        assert tap._subscription_id == "sub_123"

        # Cleanup
        await tap.stop(mock_mesh)

    @pytest.mark.asyncio
    async def test_start_when_already_running(self, tap, mock_mesh):
        """Test that start() warns when already running."""
        tap._running = True

        with patch("behavior_modeler.tap.logger") as mock_logger:
            await tap.start(mock_mesh)
            mock_logger.warning.assert_called_once()

        mock_mesh.subscribe.assert_not_called()

    @pytest.mark.asyncio
    async def test_stop_unsubscribes_from_mesh(self, tap, mock_mesh):
        """Test that stop() unsubscribes from the mesh."""
        await tap.start(mock_mesh)
        await tap.stop(mock_mesh)

        mock_mesh.unsubscribe.assert_called_once_with("sub_123")
        assert tap._running is False

    @pytest.mark.asyncio
    async def test_stop_finalizes_active_sessions(self, tap, mock_store, mock_mesh):
        """Test that stop() finalizes all active sessions."""
        await tap.start(mock_mesh)

        # Add a session manually
        session = Session(
            session_id="test_session",
            started_at=datetime.now(timezone.utc),
            events=[MagicMock(spec=FlowEvent, timestamp=datetime.now(timezone.utc))],
        )
        tap._sessions["test_session"] = session

        await tap.stop(mock_mesh)

        # Session should be saved
        mock_store.save_session.assert_called()
        assert "test_session" not in tap._sessions

    @pytest.mark.asyncio
    async def test_stop_without_mesh(self, tap):
        """Test stop() when mesh is None."""
        tap._running = True
        tap._subscription_id = "sub_123"

        await tap.stop(None)

        assert tap._running is False


# =============================================================================
# Event Handling Tests
# =============================================================================

class TestEventHandling:
    """Tests for event handling."""

    @pytest.mark.asyncio
    async def test_handle_event_creates_session(self, tap, mock_event):
        """Test that handling an event creates a new session."""
        await tap._handle_event(mock_event)

        assert "session_abc123" in tap._sessions
        session = tap._sessions["session_abc123"]
        assert len(session.events) == 1
        assert tap._events_captured == 1

    @pytest.mark.asyncio
    async def test_handle_event_adds_to_existing_session(self, tap, mock_event):
        """Test that events are added to existing sessions."""
        # First event
        await tap._handle_event(mock_event)

        # Second event
        mock_event2 = MagicMock()
        mock_event2.type = "ui.input.change"
        mock_event2.correlation_id = "session_abc123"
        mock_event2.source = "client_1"
        mock_event2.data = {}
        mock_event2.time = datetime.now(timezone.utc).isoformat()

        await tap._handle_event(mock_event2)

        session = tap._sessions["session_abc123"]
        assert len(session.events) == 2
        assert tap._events_captured == 2

    @pytest.mark.asyncio
    async def test_handle_event_without_session_id(self, tap):
        """Test that events without session ID are skipped."""
        event = MagicMock()
        event.type = "ui.unknown"
        event.correlation_id = None
        event.source = "mesh"
        event.data = {}

        with patch("behavior_modeler.tap.logger") as mock_logger:
            await tap._handle_event(event)
            mock_logger.debug.assert_called()

        assert len(tap._sessions) == 0

    @pytest.mark.asyncio
    async def test_handle_event_max_events_limit(self, tap, mock_event, config):
        """Test that sessions are finalized when max events reached."""
        config.max_events_per_session = 2

        # Add events up to limit
        await tap._handle_event(mock_event)
        await tap._handle_event(mock_event)

        # Third event should trigger finalization
        await tap._handle_event(mock_event)

        # Session should be finalized (saved and removed)
        tap.store.save_session.assert_called()

    @pytest.mark.asyncio
    async def test_handle_event_with_registry(self, mock_store, mock_registry):
        """Test event handling with ComponentRegistry enrichment."""
        tap = BehaviorTap(store=mock_store, registry=mock_registry)

        event = MagicMock()
        event.type = "ui.button.click"
        event.correlation_id = "session_123"
        event.source = "client_1"
        event.data = {"component_id": 42}
        event.time = datetime.now(timezone.utc).isoformat()

        await tap._handle_event(event)

        # Registry should be queried
        mock_registry.get.assert_called_with(42)

    @pytest.mark.asyncio
    async def test_handle_event_terminal_event(self, tap, mock_store):
        """Test that terminal events finalize the session."""
        event = MagicMock()
        event.type = "ui.form.submit"  # 'submit' is terminal
        event.correlation_id = "session_submit"
        event.source = "client_1"
        event.data = {}
        event.time = datetime.now(timezone.utc).isoformat()

        await tap._handle_event(event)

        # Session should be finalized
        mock_store.save_session.assert_called()
        assert "session_submit" not in tap._sessions

    @pytest.mark.asyncio
    async def test_handle_event_exception_handling(self, tap):
        """Test that exceptions in event handling are logged."""
        # Create an event that will cause an error
        event = MagicMock()
        event.type = "ui.test"
        event.correlation_id = "session_error"

        # Make FlowEvent.from_semantic_event raise an error
        with patch("behavior_modeler.tap.FlowEvent.from_semantic_event", side_effect=Exception("Test error")):
            with patch("behavior_modeler.tap.logger") as mock_logger:
                await tap._handle_event(event)
                mock_logger.error.assert_called()


# =============================================================================
# Session ID Extraction Tests
# =============================================================================

class TestSessionIdExtraction:
    """Tests for session ID extraction logic."""

    def test_extract_session_id_from_correlation_id(self, tap):
        """Test extraction from correlation_id."""
        event = MagicMock()
        event.correlation_id = "corr_123"
        event.data = None
        event.source = "client"

        result = tap._extract_session_id(event)
        assert result == "corr_123"

    def test_extract_session_id_from_data(self, tap):
        """Test extraction from data.session_id."""
        event = MagicMock()
        event.correlation_id = None
        event.data = {"session_id": "data_session_456"}
        event.source = "client"

        result = tap._extract_session_id(event)
        assert result == "data_session_456"

    def test_extract_session_id_from_source(self, tap):
        """Test extraction from source."""
        event = MagicMock()
        event.correlation_id = None
        event.data = {}
        event.source = "ws_client_789"

        result = tap._extract_session_id(event)
        assert result == "source_ws_client_789"

    def test_extract_session_id_none(self, tap):
        """Test when no session ID can be extracted."""
        event = MagicMock()
        event.correlation_id = None
        event.data = {}
        event.source = "mesh"  # 'mesh' source is ignored

        result = tap._extract_session_id(event)
        assert result is None

    def test_extract_session_id_non_dict_data(self, tap):
        """Test when data is not a dict."""
        event = MagicMock()
        event.correlation_id = None
        event.data = "string_data"
        event.source = "mesh"

        result = tap._extract_session_id(event)
        assert result is None


# =============================================================================
# Component ID Extraction Tests
# =============================================================================

class TestComponentIdExtraction:
    """Tests for component ID extraction."""

    def test_extract_component_id_success(self, tap):
        """Test successful component ID extraction."""
        event = MagicMock()
        event.data = {"component_id": 42}

        result = tap._extract_component_id(event)
        assert result == 42

    def test_extract_component_id_not_int(self, tap):
        """Test when component_id is not an int."""
        event = MagicMock()
        event.data = {"component_id": "not_an_int"}

        result = tap._extract_component_id(event)
        assert result is None

    def test_extract_component_id_missing(self, tap):
        """Test when component_id is missing."""
        event = MagicMock()
        event.data = {}

        result = tap._extract_component_id(event)
        assert result is None

    def test_extract_component_id_no_data(self, tap):
        """Test when data is None."""
        event = MagicMock()
        event.data = None

        result = tap._extract_component_id(event)
        assert result is None


# =============================================================================
# Terminal Event Detection Tests
# =============================================================================

class TestTerminalEventDetection:
    """Tests for terminal event detection."""

    @pytest.mark.parametrize("event_type,expected", [
        ("ui.form.submit", True),
        ("auth.logout", True),
        ("dialog.close", True),
        ("nav.navigate_away", True),
        ("flow.complete", True),
        ("system.connection.close", True),
        ("ui.button.click", False),
        ("data.load", False),
    ])
    def test_is_terminal_event(self, tap, event_type, expected):
        """Test terminal event detection."""
        event = MagicMock()
        event.type = event_type

        result = tap._is_terminal_event(event)
        assert result == expected


# =============================================================================
# Session Lock Tests
# =============================================================================

class TestSessionLocks:
    """Tests for session locking."""

    def test_get_session_lock_creates_new(self, tap):
        """Test that a new lock is created for unknown sessions."""
        lock = tap._get_session_lock("new_session")

        assert isinstance(lock, asyncio.Lock)
        assert "new_session" in tap._session_locks

    def test_get_session_lock_returns_existing(self, tap):
        """Test that existing locks are returned."""
        lock1 = tap._get_session_lock("session_1")
        lock2 = tap._get_session_lock("session_1")

        assert lock1 is lock2


# =============================================================================
# Session Finalization Tests
# =============================================================================

class TestSessionFinalization:
    """Tests for session finalization."""

    @pytest.mark.asyncio
    async def test_finalize_session_saves_session(self, tap, mock_store):
        """Test that finalization saves the session."""
        session = Session(
            session_id="test_finalize",
            started_at=datetime.now(timezone.utc),
            events=[MagicMock(spec=FlowEvent, timestamp=datetime.now(timezone.utc))],
        )
        tap._sessions["test_finalize"] = session
        tap._session_locks["test_finalize"] = asyncio.Lock()

        await tap._finalize_session("test_finalize", reason="test")

        mock_store.save_session.assert_called_once()
        assert "test_finalize" not in tap._sessions
        assert "test_finalize" not in tap._session_locks
        assert tap._sessions_completed == 1

    @pytest.mark.asyncio
    async def test_finalize_session_empty_events(self, tap, mock_store):
        """Test that empty sessions are discarded."""
        session = Session(
            session_id="empty_session",
            started_at=datetime.now(timezone.utc),
            events=[],
        )
        tap._sessions["empty_session"] = session

        with patch("behavior_modeler.tap.logger") as mock_logger:
            await tap._finalize_session("empty_session")
            mock_logger.debug.assert_called()

        mock_store.save_session.assert_not_called()

    @pytest.mark.asyncio
    async def test_finalize_session_not_found(self, tap, mock_store):
        """Test finalization of non-existent session."""
        await tap._finalize_session("nonexistent")

        mock_store.save_session.assert_not_called()

    @pytest.mark.asyncio
    async def test_finalize_session_save_failure(self, tap, mock_store):
        """Test handling of save failure."""
        mock_store.save_session.return_value = False

        session = Session(
            session_id="fail_save",
            started_at=datetime.now(timezone.utc),
            events=[MagicMock(spec=FlowEvent, timestamp=datetime.now(timezone.utc))],
        )
        tap._sessions["fail_save"] = session

        with patch("behavior_modeler.tap.logger") as mock_logger:
            await tap._finalize_session("fail_save")
            mock_logger.error.assert_called()

        assert tap._sessions_completed == 0


# =============================================================================
# Timeout Checker Tests
# =============================================================================

class TestTimeoutChecker:
    """Tests for the session timeout checker."""

    @pytest.mark.asyncio
    async def test_check_timeouts_finalizes_old_sessions(self, tap, mock_store, config):
        """Test that timed-out sessions are finalized."""
        config.session_timeout_seconds = 0  # Immediate timeout

        # Create an old session
        old_time = datetime.now(timezone.utc) - timedelta(seconds=60)
        session = Session(
            session_id="old_session",
            started_at=old_time,
            events=[MagicMock(spec=FlowEvent, timestamp=old_time)],
        )
        tap._sessions["old_session"] = session
        tap._running = True

        # Run one iteration of timeout check
        with patch("asyncio.sleep", new_callable=AsyncMock):
            tap._running = False  # Stop after one check
            try:
                await asyncio.wait_for(tap._check_timeouts(), timeout=0.1)
            except asyncio.TimeoutError:
                pass

    @pytest.mark.asyncio
    async def test_check_timeouts_handles_cancellation(self, tap):
        """Test that timeout checker handles cancellation gracefully."""
        tap._running = True

        task = asyncio.create_task(tap._check_timeouts())

        # Cancel after a short delay
        await asyncio.sleep(0.01)
        task.cancel()

        try:
            await task
        except asyncio.CancelledError:
            pass  # Expected

    @pytest.mark.asyncio
    async def test_check_timeouts_handles_exception(self, tap):
        """Test that timeout checker handles exceptions."""
        tap._running = True
        tap._sessions["bad_session"] = MagicMock()
        tap._sessions["bad_session"].events = [MagicMock()]
        tap._sessions["bad_session"].events[0].timestamp = "not_a_datetime"

        with patch("asyncio.sleep", new_callable=AsyncMock):
            with patch("behavior_modeler.tap.logger") as mock_logger:
                tap._running = False
                try:
                    await asyncio.wait_for(tap._check_timeouts(), timeout=0.1)
                except:
                    pass


# =============================================================================
# Manual Ingestion Tests
# =============================================================================

class TestManualIngestion:
    """Tests for manual session/event ingestion."""

    @pytest.mark.asyncio
    async def test_ingest_session(self, tap, mock_store):
        """Test manual session ingestion."""
        session = Session(
            session_id="manual_session",
            started_at=datetime.now(timezone.utc),
            events=[],
        )

        result = await tap.ingest_session(session)

        assert result is True
        mock_store.save_session.assert_called_once_with(session)

    @pytest.mark.asyncio
    async def test_ingest_events(self, tap, mock_store):
        """Test manual event ingestion."""
        events = [
            {"event_type": "ui.click", "timestamp": datetime.now(timezone.utc).isoformat()},
            {"event_type": "ui.submit", "timestamp": datetime.now(timezone.utc).isoformat()},
        ]

        with patch("behavior_modeler.tap.FlowEvent.from_dict") as mock_from_dict:
            mock_event = MagicMock(spec=FlowEvent)
            mock_event.timestamp = datetime.now(timezone.utc)
            mock_from_dict.return_value = mock_event

            result = await tap.ingest_events("session_123", events)

            assert result is True
            mock_store.save_session.assert_called_once()

    @pytest.mark.asyncio
    async def test_ingest_events_empty(self, tap, mock_store):
        """Test ingestion with empty events list."""
        with patch("behavior_modeler.tap.FlowEvent.from_dict", return_value=None):
            result = await tap.ingest_events("session_123", [])

            assert result is False
            mock_store.save_session.assert_not_called()


# =============================================================================
# Stats Tests
# =============================================================================

class TestStats:
    """Tests for statistics."""

    def test_get_stats(self, tap):
        """Test getting tap statistics."""
        tap._running = True
        tap._sessions["s1"] = MagicMock()
        tap._sessions["s2"] = MagicMock()
        tap._events_captured = 100
        tap._sessions_completed = 10

        stats = tap.get_stats()

        assert stats["running"] is True
        assert stats["active_sessions"] == 2
        assert stats["events_captured"] == 100
        assert stats["sessions_completed"] == 10


# =============================================================================
# Standalone Function Tests
# =============================================================================

class TestRunTapStandalone:
    """Tests for the run_tap_standalone function."""

    @pytest.mark.asyncio
    async def test_run_tap_standalone(self, mock_mesh, mock_store, config):
        """Test the standalone tap runner."""
        tap = await run_tap_standalone(mock_mesh, mock_store, config)

        assert isinstance(tap, BehaviorTap)
        assert tap._running is True
        mock_mesh.subscribe.assert_called_once()

        # Cleanup
        await tap.stop(mock_mesh)

    @pytest.mark.asyncio
    async def test_run_tap_standalone_default_config(self, mock_mesh, mock_store):
        """Test standalone runner with default config."""
        tap = await run_tap_standalone(mock_mesh, mock_store)

        assert tap.config is not None
        await tap.stop(mock_mesh)
